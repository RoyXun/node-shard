{"version":3,"sources":["../src/index.js"],"names":["hexBinMap","a","b","c","d","e","f","A","B","C","D","E","F","hashKeyArr","shards","hash","str","hexStr","parseInt","bins","hex","push","dec","join","plus","toString","init","shardConfig","length","forEach","cfg","i","name","n","weight","hashKey","insertNode","sort","compare","generateNode","shardIndex","node","high","slice","low","isPositive","Math","abs","node1","node2","sign","findRecentKey","start","end","mid","midNode","getShard","sessionIdentifier"],"mappings":"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","file":"index.js","sourcesContent":["import {murmurHash64x64 as murmurhash} from 'murmurhash-native'; \r\nimport Decimal from 'decimal.js';\r\n\r\n//反码映射\r\nconst hexBinMap = {\r\n    0: '1111',\r\n    1: '1110',\r\n    2: '1101',\r\n    3: '1100',\r\n    4: '1011',\r\n    5: '1010',\r\n    6: '1001',\r\n    7: '1000',\r\n    8: '0111',\r\n    9: '0110',\r\n    a: '0101',\r\n    b: '0100',\r\n    c: '0011',\r\n    d: '0010',\r\n    e: '0001',\r\n    f: '0000',\r\n    A: '0101',\r\n    B: '0100',\r\n    C: '0011',\r\n    D: '0010',\r\n    E: '0001',\r\n    F: '0000'\r\n};\r\n\r\n//用于存放哈希值\r\nconst hashKeyArr = [];\r\n\r\nlet shards = [];\r\n\r\n/**\r\n * 底层使用murmurhash-native的murmurHash64(x64)算法，该算法和passport Java端一致，只是得到的是十六进制字符串，\r\n * 而Java端得到的是个long类型的数字(十进制)。大数的进制转换太复杂了，直接使用decimal.js处理。\r\n * 先判断符号，负数求得原码二进制字符串再传给decimal.js，正数直接传\r\n * \r\n * @param {string} str -需要哈希处理的字符串\r\n * @return {string} - murmurhashV2算法得到的10进制有符号字符串\r\n */\r\nfunction hash(str) {\r\n    //16位十六进制数字字符串 e.g. 'e9a4fa495fd57191', '2edc3f3edb5c097'\r\n    let hexStr = murmurhash(str, 0x1234ABCD); \r\n    if (parseInt(hexStr[0], 16) > 7) {\r\n        let bins = ['0b'];\r\n        //按位取反\r\n        for (let hex of hexStr) {\r\n            bins.push(hexBinMap[hex]);\r\n        }\r\n        //利用decimal转换十进制\r\n\t\tlet dec = new Decimal(bins.join('')).plus(1).toString();\r\n\t\treturn '-' + dec;\r\n\t} else {\r\n\t\treturn new Decimal('0x' + hexStr).toString();\r\n\t}\r\n}\r\n\r\n/**\r\n *  @param {array} shardConfig - redis shard配置\r\n */\r\nfunction init(shardConfig) {\r\n    if (shards.length) return;\r\n     \r\n    shards = shardConfig;\r\n\r\n    shardConfig.forEach((cfg, i) => {\r\n        if (!cfg.name) {\r\n            for (let n = 0; n < 160 * cfg.weight; n++) {\r\n                let hashKey = hash('SHARD-' + i + '-NODE-' + n);\r\n                insertNode(hashKey, i, hashKeyArr);\r\n            }\r\n        } else {\r\n            for (let n = 0; n < 160 * cfg.weight; n++) {\r\n                let hashKey = hash(cfg.name + '*' + cfg.weight + n);\r\n                insertNode(hashKey, i, hashKeyArr);\r\n            }\r\n        }\r\n    });\r\n    //排序\r\n    hashKeyArr.sort(compare);\r\n}\r\n\r\n/**\r\n * 生成自定义哈希节点\r\n * @param {string} hashKey - 哈希值字符串\r\n * @param {number} shardIndex - shard索引\r\n */\r\nfunction generateNode(hashKey, shardIndex) {\r\n    let node; \r\n\r\n    if (hashKey.length >= 10) {\r\n        let high = parseInt(hashKey.slice(0, -8));//高位\r\n        let low = parseInt(hashKey.slice(-8));//低位\r\n        let isPositive = high > 0;\r\n\r\n        node = {\r\n            isPositive,\r\n            high: Math.abs(high),\r\n            low,\r\n            hashKey,\r\n            shardIndex\r\n        };\r\n    } else {\r\n        node = {\r\n            isPositive: hashKey > 0,\r\n            high: 0,\r\n            low: Math.abs(hashKey),\r\n            hashKey,\r\n            shardIndex\r\n        };\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\n/**\r\n * @param {string} hashKey\r\n * @param {number} shardIndex\r\n * @param {array} hashKeyArr -存放节点的数组 \r\n */\r\nfunction insertNode(hashKey, shardIndex, hashKeyArr) {\r\n    let node = generateNode(hashKey, shardIndex);\r\n    hashKeyArr.push(node);\r\n}\r\n\r\n/**\r\n * 比较函数，node1排在node2前面，返回负数；node1排在node2后面，返回正数；相等返回0\r\n * @param {object} node1 - 自定义哈希节点\r\n * @param {object} node2 - 同上\r\n */\r\nfunction compare(node1, node2) {\r\n    //先根据正负号判断大小\r\n    if (node1.isPositive < node2.isPositive) {\r\n        return -1;\r\n    } else if (node1.isPositive > node2.isPositive) {\r\n        return 1;\r\n    } \r\n    //正负号相同，再根据高位判断\r\n    let sign = node1.isPositive && 1 || -1;\r\n    if (node1.high < node2.high) {\r\n        return sign * -1;\r\n    } else if (node1.high > node2.high) {\r\n        return sign;\r\n    } else {\r\n        //高位相同，判断低位\r\n        return sign * (node1.low - node2.low);\r\n    }\r\n}\r\n\r\n/**\r\n * 二分查找\r\n */\r\nfunction findRecentKey(node, hashKeyArr, start, end) {\r\n    if (start == end) {\r\n        return;\r\n    }\r\n\r\n    if (end - start === 1) {\r\n        if (compare(hashKeyArr[end], node) > 0) {\r\n            return hashKeyArr[end];\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n\r\n    let mid = parseInt((start + end) / 2);\r\n    let midNode = hashKeyArr[mid];\r\n\r\n    if (node.hashKey == midNode.hashKey) {\r\n        return midNode;\r\n    }\r\n\r\n    if (compare(node, midNode) > 0) {\r\n        return findRecentKey(node, hashKeyArr, mid, end);\r\n    } else {\r\n        return findRecentKey(node, hashKeyArr, start, mid);\r\n    }\r\n}\r\n\r\n/**\r\n * 根据sessionIdentifier查找对应的shard\r\n */\r\nfunction getShard(sessionIdentifier) {\r\n    let hashKey = hash(sessionIdentifier);\r\n    let node = findRecentKey(generateNode(hashKey), hashKeyArr, 0, hashKeyArr.length);\r\n\r\n    return node ? shards[node.shardIndex] : shards[hashKeyArr[0].shardIndex];\r\n}\r\n\r\n\r\nexport default {init, getShard};\r\n"]}